{
    "collab_server" : "",
    "contents" : "# Key Issues (Ranked):\n# - Running Asymmetric TSP, since routes will be visually plotted. Need to do sanity check on route\n# - Error handling: i) geocode(), if there is no internet connection\n# - Several methods are not responding to explicit start point: arbitrary_insertion, repetitive_nn, two_opt. Not major issue since it is a loop; just need to tweak plotting\n# - In route(), structure should be \"route\" or \"leg\"?\n\n# Broader Issues:\n# - What if user inputs Gardens by the Bay and Cloud Forest, or Zoo and Night Safari (i.e. when they are just right next to each other/ referring to the same thing)\n# - Have option to suggest hotel based on location\n\n# Test Issues:\n# - Limit the number of attractions in a cluster(day) to force higher clustering where needed\n# - Code change: allow easy switching from automated cluster to manual cluster\n# - Output stats on the clustering technique, the mean, SD, full list, graph\n# - Check why Singapore City Gallery lat/lon is NA - is there repeat call in the API?\n\nlibrary(ggmap)\nlibrary(Rcpp)\nlibrary(sp)\nlibrary(cluster)\nlibrary(fpc)\nlibrary(combinat)\nlibrary(Matrix)\nlibrary(TSP)\nlibrary(RCurl)\nlibrary(jsonlite)\nlibrary(dplyr)\nlibrary(leaflet)\noptions(scipen=999)\n\n\n\n\n# #Upcoming feature: If no accommodation, find centoid, and pass on to hotel/airbnb search\n# test <- as.numeric(geocode(\"1.306928, 103.898943\"))\n# test2 <- revgeocode(test)\n\ncity <- \"Singapore\" #User needs to input city, and only needs to enter the POI name \ntransportMode <- \"walking\" #walking or driving\nclusterOption <- 'a' #a or m, for auto or manual identification of clusters\nmanual.clusterNum.input <- 4 #If manual cluster selected, how many clusters does user want\npoi.limit <- 6 #Number of places one can visit in a day\n\ncsv.data <- read.csv(\"home_poi.csv\", header = FALSE, stringsAsFactors = FALSE)[[1]] #Just update csv file directly for testing; first row taken as home\nhome <- csv.data[1]\ncombined <- csv.data\n# ALTERNATIVELY\n# home <- c(\"438772\")\n# # poi <- c(\"Katong V\", \"Parkway Parade\", \"Marine Parade CC\", \"City Hall\", \"Esplanade\", \"Marina Bay Sands\", \"Vivocity\", \"Sentosa\")\n# poi <- c(\"Parkway Parade\", \"Katong V\", \"Marine Parade CC\")\n# combined <- c(home, poi)\n\n\nall <- unlist(lapply(combined, FUN=function(x){paste(x, \", \", city, sep = \"\")}))\n\n# ---- RUN PHASE 1: Cluster ----\n\nall.df <- as.data.frame(all)\ncolnames(all.df) <- \"Name\"\ngeocodes <- geocode(all)\ngeocodes2 <- cbind(all.df, geocodes)\n\n#Initial plot using Leaflet (optional)\np <- leaflet() %>%\n  addTiles() %>%  # Add default OpenStreetMap map tiles\n  addMarkers(lng=geocodes2$lon, lat=geocodes2$lat, popup=geocodes2$Name)\np  # P\n\n#Initial plot using ggmap (optional)\n# plot(geocodes2$lon, geocodes2$lat, xlab=\"lon\",ylab=\"lat\")\n# sbbox <- make_bbox(lon = geocodes2$lon, lat = geocodes2$lat, f=3) \n# sbbox\n# sq_map <- get_map(location = sbbox, maptype = \"roadmap\", source = \"google\")\n# ggmap(sq_map) + geom_point(data = geocodes2, mapping = aes(x = lon, y = lat), color = \"red\", size=2)\n\n# #Old code: Use geocode() to obtain lat long\n# master <- read.csv(\"master_coordinates.csv\", header=TRUE, sep=\",\", stringsAsFactors = FALSE)\n# master.c <- cbind(master, geocode(master$Name))\n# par(pty=\"s\")\n# plot(master.c$lon, master.c$lat, xlab=\"lon\",ylab=\"lat\")\n\n\n# Cluster (exclude home)\ngeocodes3 <- geocodes2[-1,] #Remove home (assumes first row is always home)\nrownames(geocodes3) <- geocodes3[,1] #prepare data into right format to feed into kmeans() #converts column into row name\ngeocodes4 <- geocodes3[,-1]\n\n\n\nauto.clusterNum <- function(data){\n  mydata <- data\n  wss <- (nrow(mydata)-1)*sum(apply(mydata,2,var))\n  for (i in 2:(length(geocodes4[[1]])-1)) wss[i] <- sum(kmeans(mydata, centers=i)$withinss)\n  \n  wss.changes <- diff(wss, 1)/wss[1] * 100\n  change.threshold <- -15\n  auto.clusterNum <- NULL\n  for(i in seq_along(wss.changes)){\n    if(wss.changes[i] > change.threshold){ #once the abs(change) is smaller than threshold, takes that cluster number and breaks out of loop\n      auto.clusterNum <- i\n      break\n    }\n  }\n  \n  #Handles situation where: 1) Only two clusters 2) If the wss never tapers off\n  if(is.null(auto.clusterNum)){\n    auto.clusterNum <- length(wss)\n  }\n  auto.clusterNum\n  \n  # #This is where algo determines optimal cluster\n  # #Original code: Plot chart of WSS for Elbow Method, to find optimal cluster number\n  # mydata <- geocodes4\n  # wss <- (nrow(mydata)-1)*sum(apply(mydata,2,var))\n  # for (i in 2:(length(geocodes4[[1]])-1)) wss[i] <- sum(kmeans(mydata,\n  #                                                              centers=i)$withinss)\n  # plot(1:length(wss), wss, type=\"b\", xlab=\"Number of Clusters\",\n  #      ylab=\"Within groups sum of squares\")\n  # \n  # wss.changes <- diff(wss, 1)/wss[1] * 100\n  # change.threshold <- -15\n  # auto.clusterNum <- NULL\n  # for(i in seq_along(wss.changes)){\n  #   if(wss.changes[i] > change.threshold){\n  #     auto.clusterNum <- i\n  #     break\n  #   }\n  # }\n  # \n  # #Handles situation where: 1) Only two clusters 2) If the wss never tapers off\n  # if(is.null(auto.clusterNum)){\n  #   auto.clusterNum <- length(wss)\n  # }\n  #\n  # auto.clusterNum\n  #Function that takes in data, runs Elbow method, and returns optimial cluster number\n}\n\n\n#Function that takes in data, calls auto.clusterNum multiple times to get multiple optimal cluster numbers, and returns the average\navg_auto.clusterNum <- function(data, n){\n  all <- vector(mode=\"numeric\", length=n)\n  for(i in seq_along(all)){\n    all[i] <- auto.clusterNum(data)\n  }\n  result <- mean(all)\n  result\n}\n\navg_auto.clusterNum.result <- round(avg_auto.clusterNum(geocodes4, 20))\navg_auto.clusterNum.result\n\n# #ALTERNATIVELY, allow users to input number of clusters. Code moved up top\nif(clusterOption == 'm'){\n  selected.clusterNum <- manual.clusterNum.input\n} else {\n  selected.clusterNum <- avg_auto.clusterNum.result\n}\n\n#Ensures that there is a limit to number of POIs that can be visited each day (limited POIs in a cluster)  \nminClusterNum <- ceiling((length(all) - 1) / poi.limit) #Minus 1 to exclude the home\nif(selected.clusterNum < minClusterNum){\n  selected.clusterNum <- minClusterNum\n}\n\n# Run k-means clustering based on the specified number  of clusters, and plot\n\n\nrunClustering <- function(oldGeocodes, clusterNum){\n  fit <- kmeans(oldGeocodes, clusterNum) #Runs k-means\n  #plot(oldGeocodes, col=(fit$cluster +1), pch=20, cex=2)\n  clusterList <- fit$cluster\n  tempGeocodes <- cbind(oldGeocodes, clusterList)\n  colnames(tempGeocodes) <- c(\"lon\",\"lat\",\"cluster\")\n  newGeocodes <- tibble::rownames_to_column(tempGeocodes, \"Places\")\n  newGeocodes\n  \n  #Original code of runClustering function\n  # fit <- kmeans(geocodes4, selected.clusterNum) #Runs k-means\n  # plot(geocodes4, col=(fit$cluster +1), pch=20, cex=2)\n  # clusterList <- fit$cluster\n  # geocodes5 <- cbind(geocodes4, clusterList)\n  # colnames(geocodes5) <- c(\"lon\",\"lat\",\"cluster\")\n  # geocodes6 <- tibble::rownames_to_column(geocodes5, \"Places\")\n}\ngeocodes6 <- runClustering(geocodes4, selected.clusterNum)\n\n\n\n#Taking the clustering result, check that each cluster has at most 6. If yes, proceed. If not, rerun clustering iteratively\nensurePOIcap <- function(oldGeocodes, newGeocodes){\n  tempGeocodes <- newGeocodes\n  switch <- 0\n  while(switch < 1){\n    track <- 0\n    running.clusterNum <- max(tempGeocodes$cluster)\n    for(i in 1:running.clusterNum){\n      temp <- filter(tempGeocodes, cluster == i)\n      if(length(temp$Places) <= poi.limit){track <- track + 1} #Sometimes not able to hit criteria because a cluster of >6 might persist being one cluster\n    }\n    if(track == running.clusterNum){\n      switch <- 1\n    } else {\n      tempGeocodes <- runClustering(oldGeocodes, running.clusterNum + 1)\n    }\n  }\n  tempGeocodes\n  \n  # #Original code for function\n  # switch <- 0\n  # while(switch < 1){\n  #   track <- 0\n  #   running.clusterNum <- max(geocodes6$cluster)\n  #   for(i in 1:running.clusterNum){\n  #     temp <- filter(geocodes6, cluster == i)\n  #     if(length(temp$Places) <= poi.limit){track <- track + 1}\n  #   }\n  #   if(track == running.clusterNum){\n  #     switch <- 1\n  #   } else {\n  #     geocodes6 <- runClustering(geocodes4, running.clusterNum + 1)\n  #   }\n  # }\n}\nclusterNumVec <- vector(mode = \"numeric\", 10)\nclusterList <- vector(\"list\", 10)\nfor(i in 1:10){\n  temp <- ensurePOIcap(geocodes4, geocodes6)\n  clusterList[[i]] <- temp\n  # temp.clusterNum <- max(temp$cluster) #Old code where the cluster # was being recorded for each iteration\n  # clusterNumVec[i] <- temp.clusterNum\n}\n\n#Of the 10 clusterings that were done, pick out the one that had the minimum number of clusters\ngeocodes6 <- clusterList[[which.min(sapply(clusterList, FUN= function(x){max(x$cluster)}))]]\n#Plot that particular clustering\nplot(x=geocodes6$lon, y=geocodes6$lat, col=(geocodes6$cluster +1), pch=20, cex=2)\n\n#Would need user to verify the specific clusters, before running optimization\nfinal.clusterNum <- max(geocodes6$cluster) \nprint(paste(\"Final Cluster Number: \", final.clusterNum))\n\n\n\n\n\n\n# ---- RUN PHASE 2: Optimize ----\n#Function that takes in data in the format of geocodes6, and the number of clusters to filter for and analyze. Returns list containing: 1) POI sequence 2) total distance 3) lon/lat of POI, in sequence 4) route line (set of lon/lat)\noptimizeRoute <- function(data, n){\n  geocodes7 <- data[data$cluster == n, ]\n  cluster.poi <- geocodes7$Places\n  all <- c(home, cluster.poi)\n  \n  from <- as.vector(sapply(all, FUN = function(x) rep(x,length(all))))\n  to <- rep(all, length(all))\n  distresult <- mapdist(from=from, to=to, mode=transportMode) #Note: Alternative to Google Maps: http://stackoverflow.com/questions/17361909/determining-the-distance-between-two-zip-codes-alternatives-to-mapdist\n  resultmatrix <- matrix(distresult$km,nrow=length(all),ncol=length(all)) #Asymmetric TSP\n  rownames(resultmatrix) <- all\n  colnames(resultmatrix) <- all\n  resultmatrix.sym <- forceSymmetric(resultmatrix) #Force symmetry, keep upper-right triangle\n  cleanresultmatrix.sym <- as.matrix(resultmatrix.sym)\n  rownames(cleanresultmatrix.sym) <- all\n  colnames(cleanresultmatrix.sym) <- all\n  matrix.tsp <- TSP(cleanresultmatrix.sym) #Original order: labels(matrix.tsp)\n  labels(matrix.tsp)\n  \n  # result.tsp <- solve_TSP(matrix.tsp, method = \"two_opt\", start=as.integer(4)) #Note that it loops back to the first selected location. order() returns optimized order. tour_length() returns distance\n  # labels(result.tsp)\n  \n  methods <- c(\"nearest_insertion\", \"farthest_insertion\", \"cheapest_insertion\", \"nn\")\n  # methods <- c(\"nearest_insertion\", \"farthest_insertion\", \"cheapest_insertion\", \"nn\", \"arbitrary_insertion\", \"repetitive_nn\", \"two_opt\")\n  tours <- sapply(methods, FUN = function(m) solve_TSP(matrix.tsp, method = m, start=as.integer(1)), simplify = FALSE)\n  # dotchart(sort(sapply(tours, tour_length)), xlab = \"tour length\", xlim = c(0, 30)) #Plots dot chart for visualization\n  sapply(tours, tour_length)  #Returns the distances for all the methods\n  sapply(tours, labels)\n  \n  \n  best <- tours[[which.min(sapply(tours, tour_length))]]\n  best.route <- labels(best)\n  best.distance <- tour_length(best)\n  best.all <- list(best.route, best.distance)\n  \n  \n  #Plot \n  waypoints <- as.data.frame(best.all[1],stringsAsFactors = FALSE, col.names = \"Places\")\n  \n  #Data preparation: column for \"for\" and column for \"to\"\n  rte.from <- waypoints\n  colnames(rte.from) <- \"From\"\n  shiftPointDown <- function(df){\n    temp_row <- df[1,]\n    rte.to.temp <- as.data.frame(df[-1,], stringsAsFactors = FALSE)\n    rte.to <- rbind(rte.to.temp, temp_row)\n    colnames(rte.to) <- \"To\"\n    rte.to\n  }\n  rte.to <- shiftPointDown(rte.from)\n  rte.all <- as.data.frame(cbind(rte.from, rte.to), stringsAsFactors = FALSE)\n  \n  #Run route() for each pair of from/to\n  route_objects <- mapply(route, rte.all$From, rte.all$To, SIMPLIFY=FALSE, MoreArgs=list(mode=transportMode, structure=\"route\", output=\"all\"))\n  \n  #Run decodeLine() on each of the returned object, and rbind to get full list of lon/lat for plotting\n  route_df <- NULL\n  # Need decode function for route to be plotted on-road: http://stackoverflow.com/questions/30270011/ggmap-route-finding-doesnt-stay-on-roads\n  decodeLine <- function(encoded){\n    require(bitops)\n    \n    vlen <- nchar(encoded)\n    vindex <- 0\n    varray <- NULL\n    vlat <- 0\n    vlng <- 0\n    \n    while(vindex < vlen){\n      vb <- NULL\n      vshift <- 0\n      vresult <- 0\n      repeat{\n        if(vindex + 1 <= vlen){\n          vindex <- vindex + 1\n          vb <- as.integer(charToRaw(substr(encoded, vindex, vindex))) - 63  \n        }\n        \n        vresult <- bitOr(vresult, bitShiftL(bitAnd(vb, 31), vshift))\n        vshift <- vshift + 5\n        if(vb < 32) break\n      }\n      \n      dlat <- ifelse(\n        bitAnd(vresult, 1)\n        , -(bitShiftR(vresult, 1)+1)\n        , bitShiftR(vresult, 1)\n      )\n      vlat <- vlat + dlat\n      \n      vshift <- 0\n      vresult <- 0\n      repeat{\n        if(vindex + 1 <= vlen) {\n          vindex <- vindex+1\n          vb <- as.integer(charToRaw(substr(encoded, vindex, vindex))) - 63        \n        }\n        \n        vresult <- bitOr(vresult, bitShiftL(bitAnd(vb, 31), vshift))\n        vshift <- vshift + 5\n        if(vb < 32) break\n      }\n      \n      dlng <- ifelse(\n        bitAnd(vresult, 1)\n        , -(bitShiftR(vresult, 1)+1)\n        , bitShiftR(vresult, 1)\n      )\n      vlng <- vlng + dlng\n      \n      varray <- rbind(varray, c(vlat * 1e-5, vlng * 1e-5))\n    }\n    coords <- data.frame(varray)\n    names(coords) <- c(\"lat\", \"lon\")\n    coords\n  }\n  for(i in 1:length(route_objects)){\n    x <- decodeLine(route_objects[[i]]$routes[[1]]$overview_polyline$points)\n    route_df <- rbind(route_df,x)\n  }\n  \n  #Plot route\n  \n  waypoints2 <- geocode(waypoints$Places)\n  waypoints3 <- cbind(waypoints, waypoints2)\n  \n  # m <- leaflet() %>%\n  #   addTiles() %>%  # Add default OpenStreetMap map tiles\n  #   addAwesomeMarkers(lng=waypoints3$lon, lat=waypoints3$lat, label=waypoints3$Places,  group=n , icon=awesomeIcons(markerColor='red', fontFamily=\"Arial\", text=seq_along(waypoints3$lon))) %>% \n  #   addPolylines(lng=route_df$lon, lat=route_df$lat, group=n)\n  # m  # P\n  \n  # center.coord <- paste(mean(geocodes7$lat), \",\", mean(geocodes7$lon), sep=\" \")\n  # mapOutput <- qmap(center.coord, zoom = 13) +\n  #   geom_path(aes(x = lon, y = lat),  colour = \"red\", size = 1.5, data = route_df, lineend = \"round\") +\n  #   geom_point(data=waypoints3,aes(x=as.numeric(lon),y=as.numeric(lat)), size=6,color=\"yellow\") +\n  #   geom_text(data=waypoints3, aes(x=as.numeric(lon),y=as.numeric(lat), label=seq_along(lon)))\n  # mapOutput\n  # best.route\n  # best.distance\n  \n  route.output.all <- list(best.route, best.distance, waypoints3, route_df)\n  route.output.all\n  \n}\n\n#Calls optimizeRoute() on each cluster, storing returned list(s) in a list\nfinal.results <- vector(\"list\", final.clusterNum)\nfor(i in 1:final.clusterNum){ \n  final.results[[i]] <- optimizeRoute(geocodes6, i)\n}\n\n#Plot map\n#Get unique list of POIs + Home (extract from latest geocode() call in the optimizeRoute() function call)\nfinal.poi.df <- data.frame(Places=character(), lon=numeric(), lat=numeric(), stringsAsFactors=FALSE)\nfor(i in 1:final.clusterNum){\n  final.poi.df <- rbind(final.poi.df, final.results[[i]][[3]])\n}\nfinal.poi.df <- unique(final.poi.df)\n\noverlay.vector <- vector(mode=\"character\", length=final.clusterNum)\nm <- leaflet() \nfor(i in 1:final.clusterNum){\n  overlay.vector[i] <- paste(\"Day \", as.character(i))\n  m <- addTiles(m, group=paste(\"Day \", as.character(i)))\n  m <- addAwesomeMarkers(map=m, lng=final.poi.df$lon, lat=final.poi.df$lat, label=final.poi.df$Places,  group=paste(\"Day \", as.character(i)) , icon=awesomeIcons(markerColor='blue', fontFamily=\"Arial\", text=\" \")) \n  m <- addAwesomeMarkers(map=m, lng=final.results[[i]][[3]]$lon, lat=final.results[[i]][[3]]$lat, label=final.results[[i]][[3]]$Places,  group=paste(\"Day \", as.character(i)) , icon=awesomeIcons(markerColor='red', fontFamily=\"Arial\", text=seq_along(final.results[[i]][[3]]$lon))) \n  m <- addPolylines(map=m, lng=final.results[[i]][[4]]$lon, lat=final.results[[i]][[4]]$lat, group=paste(\"Day \", as.character(i)))\n}\nm <- addLayersControl(map = m, baseGroups = overlay.vector, options = layersControlOptions(collapsed = FALSE))\nm\n\n\n\n\n# ---- END OF CORE PROGRAM ----\n\n#For 1 home + 8 POIs:\n#Calls routeQueryCheck() 11 times\n#Calls distQueryCheck() 41 times\nrouteQueryCheck()\ndistQueryCheck()\n\n# final.results[[1]][[1]] #First route - POI sequence\n# final.results[[1]][[2]] #First route - total distance\n# final.results[[1]][[3]] #First route - lon/lat of POI, in sequence\n# final.results[[1]][[4]] #First route - route line (set of lon/lat)\n\n\n#Testing use of revgeocode\no <- geocode('Baylor University')\ntest <- matrix(data=c(103.9030, 1.303620), nrow=1, ncol=2)\ntest1<- as.data.frame(test, stringsAsFactors=FALSE)\ncolnames(test1) <- c(\"lon\", \"lat\")\ntest2 <- revgeocode(test1)\n\n\n\n\n#Original code behind optimizeRoute() function\n# geocodes7 <- geocodes6[geocodes6$cluster == 1, ]\n# cluster.poi <- geocodes7$Places\n# all <- c(home, cluster.poi)\n# \n# from <- as.vector(sapply(all, FUN = function(x) rep(x,length(all))))\n# to <- rep(all, length(all))\n# distresult <- mapdist(from=from, to=to, mode=transportMode) #Note: Alternative to Google Maps: http://stackoverflow.com/questions/17361909/determining-the-distance-between-two-zip-codes-alternatives-to-mapdist\n# resultmatrix <- matrix(distresult$km,nrow=length(all),ncol=length(all)) #Asymmetric TSP\n# rownames(resultmatrix) <- all\n# colnames(resultmatrix) <- all\n# resultmatrix.sym <- forceSymmetric(resultmatrix) #Force symmetry, keep upper-right triangle\n# cleanresultmatrix.sym <- as.matrix(resultmatrix.sym)\n# rownames(cleanresultmatrix.sym) <- all\n# colnames(cleanresultmatrix.sym) <- all\n# matrix.tsp <- TSP(cleanresultmatrix.sym) #Original order: labels(matrix.tsp)\n# labels(matrix.tsp)\n# \n# # result.tsp <- solve_TSP(matrix.tsp, method = \"two_opt\", start=as.integer(4)) #Note that it loops back to the first selected location. order() returns optimized order. tour_length() returns distance\n# # labels(result.tsp)\n# \n# methods <- c(\"nearest_insertion\", \"farthest_insertion\", \"cheapest_insertion\", \"nn\")\n# # methods <- c(\"nearest_insertion\", \"farthest_insertion\", \"cheapest_insertion\", \"nn\", \"arbitrary_insertion\", \"repetitive_nn\", \"two_opt\")\n# tours <- sapply(methods, FUN = function(m) solve_TSP(matrix.tsp, method = m, start=as.integer(1)), simplify = FALSE)\n# # dotchart(sort(sapply(tours, tour_length)), xlab = \"tour length\", xlim = c(0, 30)) #Plots dot chart for visualization\n# sapply(tours, tour_length)  #Returns the distances for all the methods\n# sapply(tours, labels)\n# \n# \n# best <- tours[[which.min(sapply(tours, tour_length))]]\n# best.route <- labels(best)\n# best.distance <- tour_length(best)\n# best.all <- list(best.route, best.distance)\n# \n# \n# #Plot \n# waypoints <- as.data.frame(best.all[1],stringsAsFactors = FALSE, col.names = \"Places\")\n# \n# #Data preparation: column for \"for\" and column for \"to\"\n# rte.from <- waypoints\n# colnames(rte.from) <- \"From\"\n# shiftPointDown <- function(df){\n#   temp_row <- df[1,]\n#   rte.to.temp <- as.data.frame(df[-1,], stringsAsFactors = FALSE)\n#   rte.to <- rbind(rte.to.temp, temp_row)\n#   colnames(rte.to) <- \"To\"\n#   rte.to\n# }\n# rte.to <- shiftPointDown(rte.from)\n# rte.all <- as.data.frame(cbind(rte.from, rte.to), stringsAsFactors = FALSE)\n# \n# #Run route() for each pair of from/to\n# route_objects <- mapply(route, rte.all$From, rte.all$To, SIMPLIFY=FALSE, MoreArgs=list(mode=transportMode, structure=\"route\", output=\"all\"))\n# \n# #Run decodeLine() on each of the returned object, and rbind to get full list of lon/lat for plotting\n# route_df <- NULL\n# # Need decode function for route to be plotted on-road: http://stackoverflow.com/questions/30270011/ggmap-route-finding-doesnt-stay-on-roads\n# decodeLine <- function(encoded){\n#   require(bitops)\n#   \n#   vlen <- nchar(encoded)\n#   vindex <- 0\n#   varray <- NULL\n#   vlat <- 0\n#   vlng <- 0\n#   \n#   while(vindex < vlen){\n#     vb <- NULL\n#     vshift <- 0\n#     vresult <- 0\n#     repeat{\n#       if(vindex + 1 <= vlen){\n#         vindex <- vindex + 1\n#         vb <- as.integer(charToRaw(substr(encoded, vindex, vindex))) - 63  \n#       }\n#       \n#       vresult <- bitOr(vresult, bitShiftL(bitAnd(vb, 31), vshift))\n#       vshift <- vshift + 5\n#       if(vb < 32) break\n#     }\n#     \n#     dlat <- ifelse(\n#       bitAnd(vresult, 1)\n#       , -(bitShiftR(vresult, 1)+1)\n#       , bitShiftR(vresult, 1)\n#     )\n#     vlat <- vlat + dlat\n#     \n#     vshift <- 0\n#     vresult <- 0\n#     repeat{\n#       if(vindex + 1 <= vlen) {\n#         vindex <- vindex+1\n#         vb <- as.integer(charToRaw(substr(encoded, vindex, vindex))) - 63        \n#       }\n#       \n#       vresult <- bitOr(vresult, bitShiftL(bitAnd(vb, 31), vshift))\n#       vshift <- vshift + 5\n#       if(vb < 32) break\n#     }\n#     \n#     dlng <- ifelse(\n#       bitAnd(vresult, 1)\n#       , -(bitShiftR(vresult, 1)+1)\n#       , bitShiftR(vresult, 1)\n#     )\n#     vlng <- vlng + dlng\n#     \n#     varray <- rbind(varray, c(vlat * 1e-5, vlng * 1e-5))\n#   }\n#   coords <- data.frame(varray)\n#   names(coords) <- c(\"lat\", \"lon\")\n#   coords\n# }\n# for(i in 1:length(route_objects)){\n#   x <- decodeLine(route_objects[[i]]$routes[[1]]$overview_polyline$points)\n#   route_df <- rbind(route_df,x)\n# }\n# \n# #Plot route\n# \n# waypoints2 <- geocode(waypoints$Places)\n# waypoints3 <- cbind(waypoints, waypoints2)\n# \n# # center.coord <- paste(mean(geocodes7$lat), \",\", mean(geocodes7$lon), sep=\" \")\n# # mapOutput <- qmap(center.coord, zoom = 13) +\n# #   geom_path(aes(x = lon, y = lat),  colour = \"red\", size = 1.5, data = route_df, lineend = \"round\") +\n# #   geom_point(data=waypoints3,aes(x=as.numeric(lon),y=as.numeric(lat)), size=6,color=\"yellow\") +\n# #   geom_text(data=waypoints3, aes(x=as.numeric(lon),y=as.numeric(lat), label=seq_along(lon)))\n# # mapOutput\n# \n# m <- leaflet() %>%\n#   addTiles() %>%  # Add default OpenStreetMap map tiles\n#   addAwesomeMarkers(lng=waypoints3$lon, lat=waypoints3$lat, label=waypoints3$Places,  icon=awesomeIcons(markerColor='red', fontFamily=\"Arial\", text=seq_along(waypoints3$lon))) %>%\n#   addPolylines(lng=route_df$lon, lat=route_df$lat)\n# m  # P\n# best.route\n# best.distance\n# \n# route.output.all <- list(m, best.route, best.distance)\n\n\n# For checking route visually from point A to point B\n# route_objects <- route(\"Katong V, Singapore\", \"Parkway Parade, Singapore\", mode=transportMode, structure=\"route\", output=\"all\")\n# route_df <- NULL\n# route_df <- decodeLine(route_objects$routes[[1]]$overview_polyline$points)\n# \n# qmap(\"438772, singapore\", zoom = 14) +\n#   geom_path(aes(x = lon, y = lat),  colour = \"red\", size = 1.5, data = route_df, lineend = \"round\") \n\n\n\n\n# #Intro to apply functions in r: \n# https://nsaunders.wordpress.com/2010/08/20/a-brief-introduction-to-apply-in-r/\n# http://stackoverflow.com/questions/3505701/r-grouping-functions-sapply-vs-lapply-vs-apply-vs-tapply-vs-by-vs-aggrega\n\n#Use mapply to combined two columns of lon and lat, into lon-lat?\n",
    "created" : 1522856026620.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1584852085",
    "id" : "B92C7FE1",
    "lastKnownWriteTime" : 1522856061,
    "last_content_update" : 1522856061636,
    "path" : "~/public_projects/tripbeat/script.R",
    "project_path" : "script.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}